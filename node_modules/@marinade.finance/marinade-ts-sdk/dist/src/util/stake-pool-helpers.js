"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectSpecificValidator = exports.identifyValidatorFromTx = exports.computeLSTValueInSOL = exports.computeExpectedSOL = void 0;
/* eslint-disable @typescript-eslint/no-explicit-any */
const anchor_1 = require("@coral-xyz/anchor");
const spl_stake_pool_1 = require("@solana/spl-stake-pool");
const web3_js_1 = require("@solana/web3.js");
const anchor_2 = require("./anchor");
const spl_token_3_x_1 = require("@solana/spl-token-3.x");
const conversion_1 = require("./conversion");
function computeExpectedSOL(amountToWithdraw, cxn, stakePoolTokenAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        const stakePool = yield (0, spl_stake_pool_1.getStakePoolAccount)(cxn, stakePoolTokenAddress);
        const solValue = (0, conversion_1.calcLamportsWithdrawAmount)(stakePool.account.data, (0, conversion_1.solToLamports)(amountToWithdraw));
        const withdrawalFee = solValue *
            (stakePool.account.data.stakeWithdrawalFee.numerator
                .mul(new anchor_1.BN(1e6))
                .div(stakePool.account.data.stakeWithdrawalFee.denominator)
                .toNumber() /
                1e6);
        return solValue - withdrawalFee;
    });
}
exports.computeExpectedSOL = computeExpectedSOL;
function computeLSTValueInSOL(amount, cxn, stakePoolTokenAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        const stakePool = yield (0, spl_stake_pool_1.getStakePoolAccount)(cxn, stakePoolTokenAddress);
        const solValue = (0, conversion_1.calcLamportsWithdrawAmount)(stakePool.account.data, (0, conversion_1.solToLamports)(amount));
        return solValue;
    });
}
exports.computeLSTValueInSOL = computeLSTValueInSOL;
function identifyValidatorFromTx(instructions, provider, marinadeState) {
    return __awaiter(this, void 0, void 0, function* () {
        const withdrawTxAccounts = instructions.flatMap((i) => i.keys.map((k) => k.pubkey.toString()));
        const excludedAccounts = [
            web3_js_1.SYSVAR_CLOCK_PUBKEY.toString(),
            anchor_2.STAKE_PROGRAM_ID.toString(),
            spl_token_3_x_1.TOKEN_PROGRAM_ID.toString(),
        ];
        const uniqueAccounts = withdrawTxAccounts.filter((value, index, self) => {
            return (self.indexOf(value) === index &&
                self.lastIndexOf(value) === index &&
                !excludedAccounts.includes(value));
        });
        let validatorAddress = '';
        yield Promise.all(uniqueAccounts.map((acc) => __awaiter(this, void 0, void 0, function* () {
            try {
                const accountInfo = yield (0, anchor_2.getParsedStakeAccountInfo)(provider, new web3_js_1.PublicKey(acc));
                if (accountInfo.voterAddress)
                    validatorAddress = accountInfo.voterAddress.toString();
            }
            catch (_a) {
                /* empty */
            }
        })));
        const duplicationFlag = yield marinadeState.validatorDuplicationFlag(new web3_js_1.PublicKey(validatorAddress));
        const { validatorRecords } = yield marinadeState.getValidatorRecords();
        const validatorLookupIndex = validatorRecords.findIndex(({ validatorAccount }) => validatorAccount.equals(new web3_js_1.PublicKey(validatorAddress)));
        const validatorIndex = validatorLookupIndex === -1
            ? marinadeState.state.validatorSystem.validatorList.count
            : validatorLookupIndex;
        return {
            validatorAddress: new web3_js_1.PublicKey(validatorAddress),
            duplicationFlag,
            validatorIndex,
        };
    });
}
exports.identifyValidatorFromTx = identifyValidatorFromTx;
function selectSpecificValidator(a, b, validators) {
    const scoredValidatorA = a.voteAddress
        ? validators.has(a.voteAddress.toString())
        : false;
    const scoredValidatorB = b.voteAddress
        ? validators.has(b.voteAddress.toString())
        : false;
    return ((scoredValidatorB ? b.lamports : 0) - (scoredValidatorA ? a.lamports : 0));
}
exports.selectSpecificValidator = selectSpecificValidator;
//# sourceMappingURL=stake-pool-helpers.js.map