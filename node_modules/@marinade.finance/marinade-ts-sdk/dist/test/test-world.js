"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.addValidatorInstructionBuilder = exports.sleep = exports.waitForStakeAccountActivation = exports.getSolanaTestValidatorVoteAccountPubkey = exports.executeTransaction = exports.simulateTransaction = exports.transferMinimumLamportsBalance = exports.airdropMinimumLamportsBalance = exports.getBalanceLamports = exports.airdrop = exports.PARTNER_NAME = exports.REFERRAL_CODE = exports.PROVIDER = exports.CONNECTION = exports.PROVIDER_URL = exports.CONNECTION_DEVNET = exports.PROVIDER_URL_DEVNET = exports.MARINADE_STATE_ADMIN = exports.SDK_USER = exports.STAKE_ACCOUNT_TO_WITHDRAW = exports.STAKE_ACCOUNT = exports.LAMPORTS_AIRDROP_CAP = exports.MINIMUM_LAMPORTS_BEFORE_TEST = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const src_1 = require("../src");
const util_1 = require("../src/util");
exports.MINIMUM_LAMPORTS_BEFORE_TEST = src_1.MarinadeUtils.solToLamports(2.5);
exports.LAMPORTS_AIRDROP_CAP = src_1.MarinadeUtils.solToLamports(2);
// 6LHBDKtwo69UKxWgY15vE3QykP4uf5DzZUgBiMzhEWpf
exports.STAKE_ACCOUNT = anchor_1.web3.Keypair.fromSecretKey(new Uint8Array([
    18, 172, 235, 211, 112, 44, 110, 149, 4, 64, 227, 34, 56, 159, 198, 19, 146,
    61, 87, 180, 155, 178, 178, 146, 241, 198, 208, 91, 79, 219, 120, 107, 79,
    58, 194, 166, 138, 20, 154, 53, 107, 169, 158, 49, 96, 130, 207, 101, 203,
    106, 176, 103, 94, 13, 170, 98, 66, 69, 124, 209, 44, 76, 190, 136,
]));
// EHNgTdy16497UC6Eq4pri9WicTwzPEDSj3U4Ge6nMVfr
exports.STAKE_ACCOUNT_TO_WITHDRAW = anchor_1.web3.Keypair.fromSecretKey(new Uint8Array([
    146, 213, 168, 194, 197, 182, 98, 74, 198, 138, 199, 171, 114, 229, 74,
    71, 248, 98, 187, 168, 237, 65, 224, 211, 214, 171, 205, 10, 22, 95, 103,
    128, 197, 89, 188, 173, 45, 161, 99, 206, 234, 23, 24, 32, 235, 19, 255,
    72, 224, 137, 72, 42, 71, 129, 22, 126, 255, 66, 205, 84, 246, 238, 233,
    141,
]));
// 9wmxMQ2TFxYh918RzESjiA1dUXbdRAsXBd12JA1vwWQq
exports.SDK_USER = anchor_1.web3.Keypair.fromSecretKey(new Uint8Array([
    120, 45, 242, 38, 63, 135, 84, 226, 66, 56, 76, 216, 125, 144, 38, 182, 53,
    47, 169, 251, 128, 65, 185, 237, 41, 47, 64, 53, 158, 124, 64, 2, 132, 229,
    176, 107, 25, 190, 28, 223, 58, 136, 95, 237, 236, 176, 26, 160, 11, 12,
    131, 129, 21, 8, 221, 100, 249, 221, 177, 114, 143, 231, 102, 250,
]));
// for local validator testing the SDK USER is a predefined account having enough SOL
console.log('SDK User', exports.SDK_USER.publicKey.toBase58());
// 2APsntHoKXCeHWfxZ49ADwc5XrdB8GGmxK34jVXRYZyV
exports.MARINADE_STATE_ADMIN = anchor_1.web3.Keypair.fromSecretKey(new Uint8Array([
    88, 46, 254, 11, 76, 182, 135, 63, 92, 56, 112, 173, 43, 58, 65, 74, 13, 97,
    203, 36, 231, 178, 221, 92, 234, 200, 208, 114, 32, 230, 251, 217, 17, 67,
    199, 164, 137, 164, 176, 85, 236, 29, 246, 150, 180, 35, 94, 120, 30, 17,
    18, 138, 253, 155, 218, 23, 84, 125, 225, 110, 37, 142, 253, 100,
]));
// used for the base tests that cannot start the localhost provider
exports.PROVIDER_URL_DEVNET = 'https://api.devnet.solana.com';
exports.CONNECTION_DEVNET = new anchor_1.web3.Connection(exports.PROVIDER_URL_DEVNET, {
    commitment: 'confirmed',
});
exports.PROVIDER_URL = 'http://localhost:8899';
exports.CONNECTION = new anchor_1.web3.Connection(exports.PROVIDER_URL, {
    commitment: 'confirmed',
});
exports.PROVIDER = new anchor_1.AnchorProvider(exports.CONNECTION, new anchor_1.Wallet(exports.SDK_USER), {
    commitment: 'confirmed' /*, skipPreflight: true*/,
});
exports.REFERRAL_CODE = new anchor_1.web3.PublicKey('2Q7u7ndBhSJpTNpDzkjvRyRvuzRLZSovkNRQ5SEUb64g');
exports.PARTNER_NAME = 'marinade_ts_sdk';
console.log('Referral partner', exports.PARTNER_NAME, exports.REFERRAL_CODE.toBase58());
function airdrop(to, amountLamports) {
    return __awaiter(this, void 0, void 0, function* () {
        const signature = yield exports.CONNECTION.requestAirdrop(to, amountLamports);
        yield exports.CONNECTION.confirmTransaction(signature);
        console.log('Airdrop:', src_1.MarinadeUtils.lamportsToSol(new anchor_1.BN(amountLamports)), 'SOL', 'to', to.toBase58());
    });
}
exports.airdrop = airdrop;
const getBalanceLamports = (account) => __awaiter(void 0, void 0, void 0, function* () { return exports.CONNECTION.getBalance(account); });
exports.getBalanceLamports = getBalanceLamports;
function airdropMinimumLamportsBalance(account, minimumLamportsBalance) {
    return __awaiter(this, void 0, void 0, function* () {
        const balanceLamports = new anchor_1.BN(yield (0, exports.getBalanceLamports)(account));
        if (balanceLamports.gte(minimumLamportsBalance)) {
            return;
        }
        let remainingLamportsToAirdrop = minimumLamportsBalance.sub(balanceLamports);
        while (remainingLamportsToAirdrop.gtn(0)) {
            const airdropLamports = anchor_1.BN.min(exports.LAMPORTS_AIRDROP_CAP, remainingLamportsToAirdrop);
            yield airdrop(account, airdropLamports.toNumber());
            remainingLamportsToAirdrop = remainingLamportsToAirdrop.sub(airdropLamports);
        }
    });
}
exports.airdropMinimumLamportsBalance = airdropMinimumLamportsBalance;
function transferMinimumLamportsBalance(address, provider = exports.PROVIDER, lamports = exports.MINIMUM_LAMPORTS_BEFORE_TEST) {
    return __awaiter(this, void 0, void 0, function* () {
        const ix = anchor_1.web3.SystemProgram.transfer({
            fromPubkey: provider.publicKey,
            toPubkey: address,
            lamports: BigInt(lamports.toString()),
        });
        const tx = new anchor_1.web3.Transaction().add(ix);
        return yield provider.sendAndConfirm(tx);
    });
}
exports.transferMinimumLamportsBalance = transferMinimumLamportsBalance;
function simulateTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
        const { executedSlot, blockhash } = yield setupTransaction(transaction);
        const { context: { slot: simulatedSlot }, value: { err, logs, unitsConsumed, accounts, returnData }, } = yield exports.PROVIDER.connection.simulateTransaction(transaction);
        return {
            executedSlot,
            blockhash,
            simulatedSlot,
            err,
            logs,
            unitsConsumed,
            accounts,
            returnData,
        };
    });
}
exports.simulateTransaction = simulateTransaction;
function executeTransaction(transaction, signers) {
    return __awaiter(this, void 0, void 0, function* () {
        const { executedSlot, blockhash } = yield setupTransaction(transaction);
        const transactionSignature = yield exports.PROVIDER.sendAndConfirm(transaction, signers);
        const transactionData = yield exports.CONNECTION.getParsedTransaction(transactionSignature);
        if (transactionData === null || transactionData.meta === null) {
            throw new Error(`Cannot fetch transaction data ${transactionSignature}`);
        }
        const { slot: executionSlot, meta: { err, logMessages: logs, computeUnitsConsumed: unitsConsumed }, transaction: { message: { accountKeys: accounts }, }, } = transactionData;
        return {
            executedSlot,
            blockhash,
            executionSlot,
            err,
            logs,
            unitsConsumed,
            accounts,
        };
    });
}
exports.executeTransaction = executeTransaction;
function setupTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
        const { context: { slot: executedSlot }, value: { blockhash }, } = yield exports.CONNECTION.getLatestBlockhashAndContext();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = exports.SDK_USER.publicKey;
        return {
            executedSlot,
            blockhash,
        };
    });
}
let solanaTestValidatorVotePubkey;
function getSolanaTestValidatorVoteAccountPubkey() {
    return __awaiter(this, void 0, void 0, function* () {
        if (solanaTestValidatorVotePubkey === undefined) {
            const voteAccounts = yield exports.CONNECTION.getVoteAccounts();
            // expecting run on localhost and only one vote account is available, i.e., one validator solana-test-validator
            if (voteAccounts.current.length !== 1) {
                throw new Error('Expected one vote account of solana-test-validator. Cannot continue in global local test setup.' +
                    ` Number of vote accounts found: ${voteAccounts.current.length}`);
            }
            solanaTestValidatorVotePubkey = new anchor_1.web3.PublicKey(voteAccounts.current[0].votePubkey);
        }
        return solanaTestValidatorVotePubkey;
    });
}
exports.getSolanaTestValidatorVoteAccountPubkey = getSolanaTestValidatorVoteAccountPubkey;
// Used for local solana-test-validator testing.
// The globalSetup.ts creates stake account, before the stake account can be used activation is required.
// This function waits for the stake account to be activated.
// Plus, parameter 'activatedAtLeastFor' defines how many epochs the stake account has to be activated for to be considered OK.
//       The epoch activation for at least some epochs is required by Marinade to be able to delegate.
// ---
// When cannot be activated until timeout elapses an error is thrown.
// (The timeout is considered separately for waiting for activation and for epochs).
// ---
// NOTE: the Anchor.toml configures slots_per_epoch to 32,
//       so the timeout of 30 seconds should be enough for the stake account to be activated
function waitForStakeAccountActivation({ stakeAccount = exports.STAKE_ACCOUNT.publicKey, connection = exports.CONNECTION, timeoutSeconds = 30, activatedAtLeastFor = 0, }) {
    return __awaiter(this, void 0, void 0, function* () {
        // 1. waiting for the stake account to be activated
        {
            const startTime = Date.now();
            let stakeStatus = yield connection.getStakeActivation(stakeAccount);
            while (stakeStatus.state !== 'active') {
                yield (0, exports.sleep)(1000);
                stakeStatus = yield connection.getStakeActivation(stakeAccount);
                if (Date.now() - startTime > timeoutSeconds * 1000) {
                    throw new Error(`Stake account ${stakeAccount.toBase58()} was not activated in timeout of ${timeoutSeconds} seconds`);
                }
            }
        }
        // 2. the stake account is active, but it needs to be active for at least waitForEpochs epochs
        if (activatedAtLeastFor > 0) {
            const stakeAccountData = yield (0, util_1.getParsedStakeAccountInfo)(connection, stakeAccount);
            const stakeAccountActivationEpoch = stakeAccountData.activationEpoch;
            if (stakeAccountActivationEpoch === null) {
                throw new Error('Expected stake account to be already activated. Unexpected setup error stake account:' +
                    stakeAccountData);
            }
            const startTime = Date.now();
            let currentEpoch = (yield connection.getEpochInfo()).epoch;
            if (currentEpoch <
                stakeAccountActivationEpoch.toNumber() + activatedAtLeastFor) {
                console.debug(`Waiting for the stake account ${stakeAccount.toBase58()} to be active at least for ${activatedAtLeastFor} epochs ` +
                    `currently active for ${currentEpoch - stakeAccountActivationEpoch.toNumber()} epoch(s)`);
            }
            while (currentEpoch <
                stakeAccountActivationEpoch.toNumber() + activatedAtLeastFor) {
                if (Date.now() - startTime > timeoutSeconds * 1000) {
                    throw new Error(`Stake account ${stakeAccount.toBase58()} was activated but timeout ${timeoutSeconds} elapsed when waiting ` +
                        `for ${activatedAtLeastFor} epochs the account to be activated, it's activated only for ` +
                        `${currentEpoch - stakeAccountActivationEpoch.toNumber()} epochs at this time`);
                }
                yield (0, exports.sleep)(1000);
                currentEpoch = (yield connection.getEpochInfo()).epoch;
            }
        }
    });
}
exports.waitForStakeAccountActivation = waitForStakeAccountActivation;
const sleep = (ms) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise(resolve => setTimeout(resolve, ms));
});
exports.sleep = sleep;
function addValidatorInstructionBuilder({ marinade, validatorScore, validatorVote, rentPayer, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const marinadeState = yield marinade.getMarinadeState();
        return yield marinade.marinadeFinanceProgram.program.methods
            .addValidator(validatorScore)
            .accountsStrict({
            state: marinadeState.marinadeStateAddress,
            validatorList: marinadeState.state.validatorSystem.validatorList.account,
            rentPayer,
            rent: anchor_1.web3.SYSVAR_RENT_PUBKEY,
            validatorVote,
            managerAuthority: marinadeState.state.validatorSystem.managerAuthority,
            duplicationFlag: yield marinadeState.validatorDuplicationFlag(validatorVote),
            clock: anchor_1.web3.SYSVAR_CLOCK_PUBKEY,
            systemProgram: anchor_1.web3.SystemProgram.programId,
        })
            .instruction();
    });
}
exports.addValidatorInstructionBuilder = addValidatorInstructionBuilder;
//# sourceMappingURL=test-world.js.map