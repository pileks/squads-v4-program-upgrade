"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirectStakeRootWrapper = void 0;
const solana_contrib_1 = require("@saberhq/solana-contrib");
const web3_js_1 = require("@solana/web3.js");
const sdk_1 = require("./sdk");
const utf8_1 = require("@coral-xyz/anchor/dist/cjs/utils/bytes/utf8");
const bytes_1 = require("@coral-xyz/anchor/dist/cjs/utils/bytes");
const bn_js_1 = __importDefault(require("bn.js"));
/**
 * Wrapper around the directed stake accounts.
 */
class DirectStakeRootWrapper {
    constructor(sdk, address, data) {
        this.sdk = sdk;
        this.address = address;
        this.data = data;
        sdk.registerDirectedStake(this);
    }
    get provider() {
        return this.sdk.provider;
    }
    get program() {
        return this.sdk.program;
    }
    /**
     * Getting data of the directed stake root account.
     */
    static loadData({ sdk, address, }) {
        return sdk.program.account.root.fetch(address);
    }
    static async fromData({ sdk, address, data, }) {
        const wrapper = sdk.getDirectedStake(address);
        if (wrapper) {
            return wrapper;
        }
        return new DirectStakeRootWrapper(sdk, address, data);
    }
    /**
     * When ProposalTemplateWrapper is not found in the sdk registry,
     * fetching data from cluster and ProposalTemplateWrapper.
     */
    static async load({ sdk, address, }) {
        const wrapper = sdk.getDirectedStake(address);
        if (wrapper) {
            return wrapper;
        }
        const data = await this.loadData({
            sdk,
            address,
        });
        return await this.fromData({ sdk, address, data });
    }
    /**
     * Fetching new state from the cluster.
     */
    async reload() {
        return (this.data = await DirectStakeRootWrapper.loadData({
            sdk: this.sdk,
            address: this.address,
        }));
    }
    static calculateVoteRecordAddress({ directedStakeProgramId, root, owner, }) {
        return web3_js_1.PublicKey.findProgramAddressSync([(0, utf8_1.encode)(sdk_1.DIRECTED_STAKE_SEED), root.toBytes(), owner.toBytes()], directedStakeProgramId);
    }
    static voteRecordAddress({ sdk, root, owner, }) {
        return DirectStakeRootWrapper.calculateVoteRecordAddress({
            directedStakeProgramId: sdk.program.programId,
            root,
            owner,
        });
    }
    getVoteRecordAddress(owner) {
        return DirectStakeRootWrapper.voteRecordAddress({
            sdk: this.sdk,
            root: this.address,
            owner,
        })[0];
    }
    static async getVoteRecord({ sdk, address, }) {
        return sdk.program.account.voteRecord.fetch(address);
    }
    async getVoteRecord(owner) {
        const address = this.getVoteRecordAddress(owner);
        const data = await DirectStakeRootWrapper.getVoteRecord({
            sdk: this.sdk,
            address,
        });
        return { address, data };
    }
    /**
     * Creating a new directed stake root and registering it to SDK registry.
     */
    static async create({ sdk, rootAddress = new web3_js_1.Keypair(), rentPayer, }) {
        let tx = new solana_contrib_1.TransactionEnvelope(sdk.provider, [], []);
        if (!(rootAddress instanceof web3_js_1.PublicKey)) {
            tx.addSigners(rootAddress);
            rootAddress = rootAddress.publicKey;
        }
        if (!rentPayer) {
            rentPayer = sdk.provider.walletKey;
        }
        else if (!(rentPayer instanceof web3_js_1.PublicKey)) {
            tx.addSigners(rentPayer);
            rentPayer = rentPayer.publicKey;
        }
        tx = tx.combine(new solana_contrib_1.TransactionEnvelope(sdk.provider, [
            await sdk.program.methods
                .createRoot()
                .accountsStrict({
                root: rootAddress,
                rentPayer,
                systemProgram: web3_js_1.SystemProgram.programId,
            })
                .instruction(),
        ]));
        const wrapper = await this.fromData({
            sdk,
            address: rootAddress,
            data: {
                voteCount: new bn_js_1.default(0),
            },
        });
        return {
            tx,
            wrapper,
        };
    }
    async createVoteRecord({ owner = this.sdk.provider.walletKey, rentPayer = this.sdk.provider.walletKey, validatorVote, }) {
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, []);
        if (!(rentPayer instanceof web3_js_1.PublicKey)) {
            tx.addSigners(rentPayer);
            rentPayer = rentPayer.publicKey;
        }
        if (!(owner instanceof web3_js_1.PublicKey)) {
            tx.addSigners(owner);
            owner = owner.publicKey;
        }
        const voteRecordAddress = this.getVoteRecordAddress(owner);
        const voteRecord = await this.sdk.program.account.voteRecord.fetchNullable(voteRecordAddress);
        if (voteRecord !== null) {
            throw Error(`Vote record already exists for owner ${owner.toBase58()} and ` +
                `validator vote account ${validatorVote.toBase58()}`);
        }
        return {
            tx: tx.append(await this.program.methods
                .createVote()
                .accountsStrict({
                root: this.address,
                owner,
                voteRecord: voteRecordAddress,
                validatorVote,
                rentPayer,
                systemProgram: web3_js_1.SystemProgram.programId,
            })
                .instruction()),
            address: voteRecordAddress,
        };
    }
    /**
     * Updating an existing directed stake vote account for the root and owner,
     * changing the registered validator vote account public key within it.
     */
    async updateVoteRecord({ owner = this.sdk.provider.walletKey, validatorVote, }) {
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, []);
        if (!(owner instanceof web3_js_1.PublicKey)) {
            tx.addSigners(owner);
            owner = owner.publicKey;
        }
        // when record does not exist, an exception is thrown
        const { address: voteRecordAddress } = await this.getVoteRecord(owner);
        return {
            tx: tx.append(await this.program.methods
                .updateVote()
                .accountsStrict({
                owner,
                voteRecord: voteRecordAddress,
                validatorVote,
            })
                .instruction()),
            address: voteRecordAddress,
        };
    }
    /**
     * Removing a directed stake vote account for the root and owner.
     */
    async removeVoteRecord({ owner = this.sdk.provider.walletKey, rentCollector = this.sdk.provider.walletKey, }) {
        const tx = new solana_contrib_1.TransactionEnvelope(this.provider, []);
        if (!(owner instanceof web3_js_1.PublicKey)) {
            tx.addSigners(owner);
            owner = owner.publicKey;
        }
        // when record does not exist, an exception is thrown
        const { address: voteRecordAddress } = await this.getVoteRecord(owner);
        return {
            tx: tx.append(await this.program.methods
                .removeVote()
                .accountsStrict({
                root: this.address,
                owner,
                voteRecord: voteRecordAddress,
                rentCollector,
            })
                .instruction()),
            address: voteRecordAddress,
        };
    }
    async findVoteRecords() {
        return await this.sdk.program.account.voteRecord.all([
            {
                memcmp: {
                    // VoteRecord account Anchor discriminator
                    bytes: bytes_1.bs58.encode(new Uint8Array([112, 9, 123, 165, 234, 9, 157, 167])),
                    offset: 0,
                },
            },
            {
                memcmp: {
                    bytes: this.address.toBase58(),
                    offset: 8,
                },
            },
        ]);
    }
}
exports.DirectStakeRootWrapper = DirectStakeRootWrapper;
//# sourceMappingURL=DirectStakeRootWrapper.js.map