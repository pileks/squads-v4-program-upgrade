"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const web3_js_1 = require("@solana/web3.js");
const src_1 = require("../src");
const bn_js_1 = __importDefault(require("bn.js"));
describe('SDK', () => {
    let connection;
    let blockhash;
    let lastValidBlockHeight;
    let user;
    let sdk;
    let referralCode;
    beforeAll(() => {
        connection = new web3_js_1.Connection('http://127.0.0.1:8899', { commitment: 'finalized' });
        sdk = new src_1.NativeStakingSDK();
        referralCode = new web3_js_1.PublicKey('rEfVaAYZam5BChbCanvFornX2T8Xa9LG1s5KAAbs6pS');
    });
    const refreshBlockhash = () => __awaiter(void 0, void 0, void 0, function* () {
        const latestBlockhashResult = yield connection.getLatestBlockhash();
        blockhash = latestBlockhashResult.blockhash;
        lastValidBlockHeight = latestBlockhashResult.lastValidBlockHeight;
    });
    beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
        user = new web3_js_1.Keypair();
        yield refreshBlockhash();
        const signature = yield connection.requestAirdrop(user.publicKey, 1000000000000);
        yield connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });
        yield new Promise((resolve) => setTimeout(resolve, 1e3));
    }));
    describe('creating new stake account in Native', () => {
        it('works with V0 transaction and referral', () => __awaiter(void 0, void 0, void 0, function* () {
            const { referralInstructions } = sdk.buildReferralInstructions(referralCode);
            const { createAuthorizedStake, stakeKeypair } = sdk.buildCreateAuthorizedStakeInstructions(user.publicKey, new bn_js_1.default(100e9));
            const versionedTransaction = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
                payerKey: user.publicKey,
                recentBlockhash: blockhash,
                instructions: [
                    ...referralInstructions,
                    ...createAuthorizedStake,
                ],
            }).compileToV0Message());
            versionedTransaction.sign([user, stakeKeypair]);
            const signature = yield connection.sendTransaction(versionedTransaction);
            yield connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });
            console.log(signature);
        }));
        it('works with legacy transaction and referral', () => __awaiter(void 0, void 0, void 0, function* () {
            const legacyTransaction = new web3_js_1.Transaction({
                feePayer: user.publicKey,
                blockhash,
                lastValidBlockHeight: lastValidBlockHeight,
            });
            const { referralInstructions } = sdk.buildReferralInstructions(referralCode);
            legacyTransaction.add(...referralInstructions);
            const { createAuthorizedStake, stakeKeypair } = sdk.buildCreateAuthorizedStakeInstructions(user.publicKey, new bn_js_1.default(100e9));
            legacyTransaction.add(...createAuthorizedStake);
            legacyTransaction.sign(user, stakeKeypair);
            const serializedTransaction = legacyTransaction.serialize();
            const signature = yield connection.sendRawTransaction(serializedTransaction);
            yield connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });
            console.log(signature);
        }));
    });
    describe('authorizing existing stake account in Native', () => {
        it('works with V0 transaction and referral', () => __awaiter(void 0, void 0, void 0, function* () {
            const stakeKeypair = new web3_js_1.Keypair();
            {
                const versionedTransaction = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
                    payerKey: user.publicKey,
                    recentBlockhash: blockhash,
                    instructions: web3_js_1.StakeProgram.createAccount({
                        fromPubkey: user.publicKey,
                        stakePubkey: stakeKeypair.publicKey,
                        authorized: {
                            staker: user.publicKey,
                            withdrawer: user.publicKey,
                        },
                        lamports: 1e9,
                    }).instructions,
                }).compileToV0Message());
                versionedTransaction.sign([user, stakeKeypair]);
                const signature = yield connection.sendTransaction(versionedTransaction);
                yield connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });
                yield refreshBlockhash();
            }
            const { referralInstructions } = sdk.buildReferralInstructions(referralCode);
            const authorizeInstructions = sdk.buildAuthorizeInstructions(user.publicKey, [stakeKeypair.publicKey]);
            const versionedTransaction = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
                payerKey: user.publicKey,
                recentBlockhash: blockhash,
                instructions: [
                    ...referralInstructions,
                    ...authorizeInstructions,
                ],
            }).compileToV0Message());
            versionedTransaction.sign([user]);
            const signature = yield connection.sendTransaction(versionedTransaction);
            yield connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });
            console.log(signature);
        }));
        it('works with legacy transaction and referral', () => __awaiter(void 0, void 0, void 0, function* () {
            const stakeKeypair = new web3_js_1.Keypair();
            {
                const versionedTransaction = new web3_js_1.VersionedTransaction(new web3_js_1.TransactionMessage({
                    payerKey: user.publicKey,
                    recentBlockhash: blockhash,
                    instructions: web3_js_1.StakeProgram.createAccount({
                        fromPubkey: user.publicKey,
                        stakePubkey: stakeKeypair.publicKey,
                        authorized: {
                            staker: user.publicKey,
                            withdrawer: user.publicKey,
                        },
                        lamports: 1e9,
                    }).instructions,
                }).compileToV0Message());
                versionedTransaction.sign([user, stakeKeypair]);
                const signature = yield connection.sendTransaction(versionedTransaction);
                yield connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });
                yield refreshBlockhash();
            }
            const legacyTransaction = new web3_js_1.Transaction({
                feePayer: user.publicKey,
                blockhash,
                lastValidBlockHeight: lastValidBlockHeight,
            });
            const { referralInstructions } = sdk.buildReferralInstructions(referralCode);
            legacyTransaction.add(...referralInstructions);
            const authorizeInstructions = sdk.buildAuthorizeInstructions(user.publicKey, [stakeKeypair.publicKey]);
            legacyTransaction.add(...authorizeInstructions);
            legacyTransaction.sign(user);
            const serializedTransaction = legacyTransaction.serialize();
            const signature = yield connection.sendRawTransaction(serializedTransaction);
            yield connection.confirmTransaction({ signature, blockhash, lastValidBlockHeight });
            console.log(signature);
        }));
    });
});
//# sourceMappingURL=sdk.test.js.map